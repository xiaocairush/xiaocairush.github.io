



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta http-equiv="x-dns-prefetch-control" content="on">
      <link rel="dns-prefetch" href="//oi-wiki.org">
      <link rel="dns-prefetch" href="//search.oi-wiki.org">
      <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
      <link rel="dns-prefetch" href="//api.github.com">
      <link rel="dns-prefetch" href="//cdn-for-oi-wiki.billchn.com">
      <link rel="dns-prefetch" href="//www.google-analytics.com">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="https://xiaocairush.github.io/java%E5%90%8E%E7%AB%AF/java.util.concurrent.locks%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../..">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-4.4.2">
    
    
      
        <title>java.util.concurrent.locks源码剖析</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.30686662.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../assets/javascripts/modernizr.27508f0e.js"></script>
    
    
      
        <style>@font-face{font-family:'Fira Sans';font-style:normal;font-weight:300;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:italic;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot);src:local('Fira Sans'),local('FiraSans-Italic'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:700;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Mono';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot);src:local('Fira Mono'),local('FiraMono-Normal'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.svg#FiraMono) format('svg')}body,input{font-family:"Fira Sans","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Fira Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.2.3/iconfont/material-icons.min.css">
    
      <link rel="manifest" href="../../manifest.webmanifest">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#javautilconcurrentlocks" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://xiaocairush.github.io/" title="知识总结" class="md-header-nav__button md-logo">
          
            <i class="md-icon">school</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              知识总结
            </span>
            <span class="md-header-nav__topic">
              
                java.util.concurrent.locks源码剖析
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../ZooKeeper-overview/" class="md-tabs__link md-tabs__link--active">
          java后端
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://xiaocairush.github.io/" title="知识总结" class="md-nav__button md-logo">
      
        <i class="md-icon">school</i>
      
    </a>
    知识总结
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../about.md" title="About" class="md-nav__link">
      About
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      java后端
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        java后端
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../ZooKeeper-overview/" title="ZooKeeper" class="md-nav__link">
      ZooKeeper
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spark-Overview/" title="Spark" class="md-nav__link">
      Spark
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Resources/" title="Resources" class="md-nav__link">
      Resources
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="同步工具类" class="md-nav__link">
      同步工具类
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../java-SE8-in-practice/" title="java-SE8-in-practice" class="md-nav__link">
      java-SE8-in-practice
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../vim-learning-notes/" title="vim" class="md-nav__link">
      vim
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../understanding-REST/" title="理解REST" class="md-nav__link">
      理解REST
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../spring-callstack/" title="spring" class="md-nav__link">
      spring
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../BlockingQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="BlockingQueue源码剖析" class="md-nav__link">
      BlockingQueue源码剖析
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../ConcurrentHashMap%281.8%E7%89%88%E6%9C%AC%29%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="ConcurrentHashMap" class="md-nav__link">
      ConcurrentHashMap
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        java.util.concurrent.locks源码剖析
      </label>
    
    <a href="./" title="java.util.concurrent.locks源码剖析" class="md-nav__link md-nav__link--active">
      java.util.concurrent.locks源码剖析
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    参考
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lock" class="md-nav__link">
    Lock接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#condition" class="md-nav__link">
    Condition接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reentrantlock" class="md-nav__link">
    ReentrantLock
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    核心成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    核心方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sync" class="md-nav__link">
    Sync
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nonfairsync" class="md-nav__link">
    NonfairSync
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fairsync" class="md-nav__link">
    FairSync
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#abstractqueuedsynchronizer" class="md-nav__link">
    AbstractQueuedSynchronizer
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    内部类
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conditionobject" class="md-nav__link">
    ConditionObject
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    核心成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    核心方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#abstractownablesynchronizer" class="md-nav__link">
    AbstractOwnableSynchronizer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      <!-- 
      
       -->
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Redis-CheatSheet/" title="Redis" class="md-nav__link">
      Redis
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    参考
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lock" class="md-nav__link">
    Lock接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#condition" class="md-nav__link">
    Condition接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reentrantlock" class="md-nav__link">
    ReentrantLock
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    核心成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    核心方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sync" class="md-nav__link">
    Sync
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nonfairsync" class="md-nav__link">
    NonfairSync
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fairsync" class="md-nav__link">
    FairSync
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#abstractqueuedsynchronizer" class="md-nav__link">
    AbstractQueuedSynchronizer
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    内部类
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conditionobject" class="md-nav__link">
    ConditionObject
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    核心成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    核心方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#abstractownablesynchronizer" class="md-nav__link">
    AbstractOwnableSynchronizer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      <!-- 
      
       -->
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="javautilconcurrentlocks">java.util.concurrent.locks源码剖析<a class="headerlink" href="#javautilconcurrentlocks" title="Permanent link">&para;</a></h1>
<h2 id="_1">参考<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html">英文文档</a><br/>
<a href="http://tutorials.jenkov.com/java-util-concurrent/index.html">英文 jenkov</a><br/>
<a href="http://blog.csdn.net/defonds/article/details/44021605/">中文 defonds</a><br/></p>
<h2 id="lock">Lock接口<a class="headerlink" href="#lock" title="Permanent link">&para;</a></h2>
<p>接口定义：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span>package java.util.concurrent.locks;
import java.util.concurrent.TimeUnit;

public interface Lock {

    void lock();

    void lockInterruptibly() throws InterruptedException;

    boolean tryLock();

    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    void unlock();

    // 依赖于Condition接口
    Condition newCondition();
}
</pre></div>
</td></tr></table>
<h2 id="condition">Condition接口<a class="headerlink" href="#condition" title="Permanent link">&para;</a></h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span>public interface Condition {

    void await() throws InterruptedException;

    void awaitUninterruptibly();

    long awaitNanos(long nanosTimeout) throws InterruptedException;

    boolean await(long time, TimeUnit unit) throws InterruptedException;

    boolean awaitUntil(Date deadline) throws InterruptedException;

    void signal();

    void signalAll();
}
</pre></div>
</td></tr></table>
<h2 id="reentrantlock">ReentrantLock<a class="headerlink" href="#reentrantlock" title="Permanent link">&para;</a></h2>
<p>参考这篇<a href="http://blog.csdn.net/tangyongzhe/article/details/44227593">《ReentrantLock源码分析》</a></p>
<h3 id="_2">核心成员<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>ReentrantLock只有一个成员sync</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    // 提供所有实现机制的同步器
    private final Sync sync;
</pre></div>
</td></tr></table>
<h3 id="_3">核心方法<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>可以看出ReentrantLock只是Sync的一个代理</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span>public class ReentrantLock implements Lock, java.io.Serializable {

    // 默认是非公平锁
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    public void lock() {
        sync.lock();
    }

    public void unlock() {
        sync.release(1);
    }

    public boolean tryLock() {
        return sync.nonfairTryAcquire(1);
    }

    // 要求状态值减释放数，如果当前线程不是独自模式下的拥有者，那么它无权修改状态值，抛异常，可见ReentrantLock是独占锁
    protected final boolean tryRelease(int releases) {
            // 计算新的状态值
            int c = getState() - releases;
            // 如果线程不是独自模式下的拥有者，那么它就无权要求修改状态值，就抛出异常
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }

    public Condition newCondition() {
        return sync.newCondition();
    }
}
</pre></div>
</td></tr></table>
<h3 id="_4">数据结构<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>我们主要关心这些数据结构的成员以及核心方法</p>
<h4 id="sync">Sync<a class="headerlink" href="#sync" title="Permanent link">&para;</a></h4>
<p>从定义可以看出Sync是一个抽象类，继承了AbstractQueuedSynchronizer，它的实现类有FairSync和NonfairSync.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span> abstract static class Sync extends AbstractQueuedSynchronizer {
        // 没有定义成员

        // 子类需要去实现lock
        abstract void lock();

        final ConditionObject newCondition() {
            // ConditionObject继承自AbstractQueuedSynchronizer
            return new ConditionObject();
        }
 }
</pre></div>
</td></tr></table>
<h4 id="nonfairsync">NonfairSync<a class="headerlink" href="#nonfairsync" title="Permanent link">&para;</a></h4>
<p>默认的同步机制，发现这个类非常简单，主要调用AbstractQueuedSynchronizer，因此，要了解ReentrantLock，最重要的是了解AbstractQueuedSynchronizer，同时注意对比FairSync和NonfairSync。 <br/>
非公平锁（Nonfair）：获取锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    static final class NonfairSync extends Sync {

        final void lock() {
            // 如果sync中的state没有被任何线程占有，则设定当前线程为锁的拥有者
            if (compareAndSetState(0, 1))
                // AbstractOwnableSynchronizer中的方法，设置当前线程为锁的拥有者
                setExclusiveOwnerThread(Thread.currentThread());
            // 否则当前线程需要和sync队列中的其它线程竞争state的占有权
            else
                acquire(1);
        }


        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }

        //非公平锁的获取方法，值得注意的是：这个方法实际是在NonfairSync的父类Sync中
    final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            // 获取state的值
            int c = getState();
            // 如果state没被占有，就独占它
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            // 如果state已经被占有，并且是被当前线程占有的
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                // 如果引用次数溢出，抛出异常而不是返回false
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                // 更新引用次数
                setState(nextc);
                return true;
            }
            // 如果已被其他线程占有，那么不能修改state的值
            return false;
        }

    }
</pre></div>
</td></tr></table>
<h4 id="fairsync">FairSync<a class="headerlink" href="#fairsync" title="Permanent link">&para;</a></h4>
<p>公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 </p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span>static final class FairSync extends Sync {
        private static final long serialVersionUID = -3000897897090466540L;

        final void lock() {
            acquire(1);
        }

        /**
         * Fair version of tryAcquire.  Don&#39;t grant access unless
         * recursive call or no waiters or is first.
         */
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            // 没有没线程占有
            if (c == 0) {
                // 必须是队列中的第一个线程，才能获取state的使用权，修改state的值
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            // 当前线程已经获得state的使用权
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
    }
</pre></div>
</td></tr></table>
<h2 id="abstractqueuedsynchronizer">AbstractQueuedSynchronizer<a class="headerlink" href="#abstractqueuedsynchronizer" title="Permanent link">&para;</a></h2>
<p>简称AQS，是一个非常核心的类，也是本文的重点关注对象。其实AQS主要就是维护了一个状态值，release对状态值做减法，acquire对状态值做加法。并且AQS提供了独占和共享两种模式。</p>
<h3 id="_5">内部类<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>AQS中有两个内部类：Node和ConditionObject。</p>
<h4 id="node">Node<a class="headerlink" href="#node" title="Permanent link">&para;</a></h4>
<p>Node是等待队列中的节点类。
等待队列是<a href="https://people.csail.mit.edu/shanir/publications/CLH.pdf">"CLH" (Craig, Landin, and Hagersten)锁队列</a>的一种变体。CLH锁一般用作<a href="https://baike.baidu.com/item/%E8%87%AA%E6%97%8B%E9%94%81">自旋锁（spinlocks）</a>。然而这里使用了相同的策略，把关于thread的控制信息保存在前一个节点中，只不过会阻塞。每个节点中的状态字段都记录了线程是否应该阻塞。节点会在前一个节点释放的时候收到信号被唤醒。因此队列中的每一个节点充当了一种特定通知风格的监视器，同时持有一个正在等待的线程。状态字段不控制线程是否授予锁等。如果线程在队列中的第一个的话，可能尝试获取锁。但是拍照第一个并不能保证获取锁成功；只是给予这个线程参与竞争的条件。所以当前被释放的竞争者可能还要等待。<br/>
为了让一个CLH锁入队，你可以让它自动拼接到新的tail中。离队只需要重新设置head字段。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      +------+  prev +-----+       +-----+
 head |      | &lt;---- |     | &lt;---- |     |  tail
      +------+       +-----+       +-----+
</pre></div>
</td></tr></table>
<p>入队与离队分别是作用于tail和head的原子操作。然而，由于超时和中断可能导致线程被取消，node还需要确定它的下一个节点是谁。相比原来CLH锁的实现，增加了prev字段主要用来处理线程被取消这种情况。如果一个node中的线程被取消了，它的下一个节点就需要重新找一个没有被取消的节点来作为前继。想了解自旋锁的相似机制，可以看Scott和Scherer的<a href="http://www.cs.rochester.edu/u/scott/synchronization/">论文</a>。<br></p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    static final class Node {
         /** Marker to indicate a node is waiting in shared mode */
        static final Node SHARED = new Node();
        /** Marker to indicate a node is waiting in exclusive mode */
        static final Node EXCLUSIVE = null;

        /** waitStatus的值，表示thread被取消了 */
        static final int CANCELLED =  1;
        /** waitStatus的值，表示下一个节点的线程需要阻塞 */
        static final int SIGNAL    = -1;
        /** waitStatus的值，表示thread正在等待某个条件 */
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;

        volatile int waitStatus;

        volatile Node prev;

        volatile Node next;

        volatile Thread thread;

        Node nextWaiter;
    }
</pre></div>
</td></tr></table>
<h4 id="conditionobject">ConditionObject<a class="headerlink" href="#conditionobject" title="Permanent link">&para;</a></h4>
<p>仅列出重要的成员以及方法。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166</pre></div></td><td class="code"><div class="highlight"><pre><span></span>/*
 * 维护了一个条件队列，注意区别于AQS中的同步队列。
 * 条件队列用来记录未满足条件的线程，每当一个线程需要等待条件满足的时候，就加入条件队列进行等待；
 * 当条件被满足的时候，线程就会把等待队列中所有的线程按照顺序加入到同步队列，
 * 并与同步队列竞争state的使用权。
 */
public class ConditionObject implements Condition, java.io.Serializable {

         // 条件队列的第一个节点
         private transient Node firstWaiter;

         // 条件队列的最后一个节点
         private transient Node lastWaiter;

         public ConditionObject() { }

         public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            // 添加了一个当前线程节点到条件队列的尾部
            Node node = addConditionWaiter();
            // 完全释放当前线程对state的占有权，唤醒同步队列中第一个等待的线程，并记录当前线程占有的state的值
            int savedState = fullyRelease(node);
            int interruptMode = 0;

            // 等待另一个其它线程将当前线程从条件队列加入到同步队列中（调用sigal函数）
            while (!isOnSyncQueue(node)) {
                // 当前线程被挂起，等待被唤醒
                LockSupport.park(this);
                // 如果是因为被中断而醒过来，就把当前线程直接加入到同步队列中
                // 自己将自己加入同步队列，需要抛异常，如果等待其它线程将自己加入同步队列，不需要抛异常
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
                 // 也有可能是由于未知原因而醒过来，这时候interruptMode不是0，所以需要一个循环来确保当前线程被加入到同步队列中
            }

            // 当前线程与同步队列中其它的线程进行竞争，直到当前线程获取到state的使用权
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            // 遍历条件队列，移除所有被取消的线程
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            // 如果被中断了，并且是通过其他线程将当前线程加入到同步队列中的
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }


        private Node addConditionWaiter() {
            Node t = lastWaiter;
            // If lastWaiter is cancelled, clean out.
            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }

        // 遍历条件队列，移除所有被取消的线程
         private void unlinkCancelledWaiters() {
            Node t = firstWaiter;
            Node trail = null;
            // 从前向后遍历条件队列
            while (t != null) {
                Node next = t.nextWaiter;
                // 在条件队列中，如果waitStatus != CONDITION，表示线程被取消
                if (t.waitStatus != Node.CONDITION) {
                    t.nextWaiter = null;
                    if (trail == null)
                        firstWaiter = next;
                    else
                        trail.nextWaiter = next;
                    if (next == null)
                        lastWaiter = trail;
                }
                else
                    trail = t;
                t = next;
            }
        }

        // 线程醒过来之后检查是否被中断，
        // 如果没有被中断，返回0；
        // 如果被中断了，且自己可以将当前线程加入到同步队列中，返回THROW_IE；
        // 如果被中断了，通过等待其它线程将当前线程加入到同步队列中，返回REINTERRUPT。
        private int checkInterruptWhileWaiting(Node node) {
            return Thread.interrupted() ?
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
                0;
        }

        // 将当前线程添加到同步队列中，返回是否自己可以将自己加入到同步队列中
        final boolean transferAfterCancelledWait(Node node) {
        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
            enq(node);
            return true;
        }
        /*
         * If we lost out to a signal(), then we can&#39;t proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         */
        // 等待其他线程通过signal把当前线程加入到同步队列中
        while (!isOnSyncQueue(node))
            Thread.yield();
        return false;
    }

    private void reportInterruptAfterWait(int interruptMode)
            throws InterruptedException {
            // 中断之后抛异常
            if (interruptMode == THROW_IE)
                throw new InterruptedException();
            // 中断之后当前线程重新进入中断状态
            else if (interruptMode == REINTERRUPT)
                selfInterrupt();
        }

        // 将条件队列中的所有线程加入到同步队列中
        public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                // 将条件队列中的所有线程加入到同步队列中
                doSignal(first);
        }

        private void doSignal(Node first) {
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
            } while (!transferForSignal(first) &amp;&amp;
                     (first = firstWaiter) != null);
        }

        final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
         // 如果线程已被取消，就不放入同步队列中
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        // 如果同步队列中前一个线程已被取消或者将前一个线程状态设置成signal失败，就唤醒该线程与同步队列其它线程竞争
        if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }
}
</pre></div>
</td></tr></table>
<h3 id="_6">核心成员<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    /**
     * 等待队列的头结点，它是一个虚拟节点，延迟初始化。
     * 如果head != null，可以保证head.waitStatus不是CANCELLED
     */
    private transient volatile Node head;

    // 等待队列尾节点，只能通过enq来加入新等待节点
    private transient volatile Node tail;

    // AQS对象的状态，初始值是0，表示state没有被任何线程占有
    // AQS最重要的成员，不同场景下具有不同的含义，一般指锁被引用的次数
    // AQS提供了竞争这个状态值占有权的框架
    private volatile int state;
</pre></div>
</td></tr></table>
<h3 id="_7">核心方法<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191</pre></div></td><td class="code"><div class="highlight"><pre><span></span>public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {

    // 在独占模式下获取state的占有权，并使state加arg
    public final void acquire(int arg) {
        /**
         * tryAcquire在FairSync和NonfairSync等AQS的子类中被实现。
         * 
         * 首先调用tryAcquire方法来尝试独占并修改state，
         * tryAcquire如果返回false，就说明已经有thread获得了state的占有权，当前线程无权修改state，
         * 这时候（执行acquireQueued方法）把当前节点入队并参与竞争state的占有权，当前节点变为首节点的时候获得state的占有权，state加arg。
         * 如果当前线程在竞争过程中被中断过，则把当前线程恢复到中断状态。
         */
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

    // 添加当前线程节点到等待队列中
    private Node addWaiter(Node mode) {
        // 构造线程节点
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            // CAS操作，更新尾节点
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        // pred是空或者CAS操作失败（尾节点已变），就入队
        enq(node);
        return node;
    }

    // 循环嵌套CAS，直到CAS成功为止
    // 将节点node加入到等待队列尾部
     private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            // 队列为空
            if (t == null) { // Must initialize
                // 注意这时候创建并设置虚拟的头结点，而不是在创建AQS对象的时候，属于延迟加载，创建完虚拟头结点仍然继续循环
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

     /*
      * 在独占不可中断模式下，当前线程与Sync队列中的其它线程竞争。
      * 当前线程成为队列中首节点的时，它获得state的占有权，并給state加arg；
      * 否则，Sync队列中存在有效（没有被取消）的线程，由于队列中前面的线程拥有更高的权利使用state，
      * 所以当前线程就需要阻塞，当前一个线程使用完state之后唤醒当前线程。
      * 线程处于阻塞状态时，也可以被中断而醒来，由于是不可中断模式，所以会记录并清除中断状态，
      * 将中断状态返回给调用方处理，例如acquire中会把当前线程恢复到中断状态。
      */
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                // 等待队列是一个双向列表，这里p是node的前节点
                final Node p = node.predecessor();
                // 如果是队列中第一个线程，就获得state的占有权，并使用state
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 如果不是队列中第一个线程，那么竞争失败，它无权使用state，
                // 检查队列中前面的线程是否有效（没有被取消），如果存在有效的线程，
                // 当前线程就需要阻塞，在线程醒过来之后检查是否被中断，如果被中断了，
                // 就清除中断标志位继续竞争state的使用权，但是要记录当前线程在竞争过程被中断过
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // 头结点出等待队列
    private void setHead(Node node) {
        head = node;
        node.thread = null;
        node.prev = null;
    }

     // 如果队列中存在有效的线程（没有被取消的）排在当前线程前面，那么当前线程就需要被阻塞，因为前面的线程等了更长的时间，拥有更高的使用权
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        //waitStatus初始值为0
        int ws = pred.waitStatus;
        // 前一个线程未使用完state，当前线程就要被阻塞
        if (ws == Node.SIGNAL)
            // pred节点正在请求一个signal信号，所以它可以被安全挂起
            return true;
        // 在Sync队列中，如果大于0表示线程处于被取消的状态，
        // 被取消的线程没有必要获取state的使用权，所以直接从队列中删除取消的线程，不让它们参与竞争。暂时不挂起当前线程。
        if (ws &gt; 0) {
             // 删除所有被取消的先继节点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don&#39;t park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            // 前一个节点没有被取消，暂时不挂起当前线程，将前一个线程状态设置为需要sigal信号（未使用完state），
            // 下次竞争如果发现前一个线程仍没有使用完state再挂起
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

      private final boolean parkAndCheckInterrupt() {
      // 挂起当前线程，在被挂起的情况下，有三种情况会被唤醒，具体见park方法注释
        LockSupport.park(this);
        // 获取中断标记，如果中断标记是true，会清除中断标记
        return Thread.interrupted();
    }

    // 释放state的使用权
    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            int savedState = getState();
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }

    public final boolean release(int arg) {
        // 如果当前线程释放state使用权成功（独占模式即有权利将state减arg成功），
        // 就唤醒队列中的等待的第一个线程。
        if (tryRelease(arg)) {
            // head指向的是虚节点，没有记录线程id，head下一个节点才存了第一个线程
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    // 唤醒node的下一个节点
    private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        // 找到下一个没有被取消的线程节点，在sync队列中，waitStatus &gt; 0 表示当前节点中的线程被取消
        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            //从后向前遍历，找到最前面的一个没有被取消的线程
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
}
</pre></div>
</td></tr></table>
<h3 id="abstractownablesynchronizer">AbstractOwnableSynchronizer<a class="headerlink" href="#abstractownablesynchronizer" title="Permanent link">&para;</a></h3>
<p>AQS继承了这个抽象类，这个类非常简单，所有成员及方法定义如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span>public abstract class AbstractOwnableSynchronizer
    implements java.io.Serializable {

    protected AbstractOwnableSynchronizer() { }

     // 独占独占模式下占有Synchronizer的线程对象
    private transient Thread exclusiveOwnerThread;

     // 赋予thread对锁的排他访问权限
    protected final void setExclusiveOwnerThread(Thread thread) {
        exclusiveOwnerThread = thread;
    }

    // 获取独占锁的线程对象
    protected final Thread getExclusiveOwnerThread() {
        return exclusiveOwnerThread;
    }
}
</pre></div>
</td></tr></table>
                
                  
                
              
              <!-- 
                 
 
 
<hr><blockquote class="page-copyright">
  <span><i class="md-icon">build</i>本页面最近更新：</span><span class="facts_modified"></span>，<a class="edit_history">更新历史</a><br>
  <span><i class="md-icon">edit</i>发现错误？想一起完善？ <a href="None" title="编辑此页" class="page_edit_url">在 GitHub 上编辑此页！</a></span><br>
  <span><i class="md-icon">people</i>本页面贡献者：</span><span class="page_contributors">OI-wiki</span><br>
  <span><i class="md-icon">copyright</i>本页面的全部内容在 <strong></strong> 协议之条款下提供，附加条款亦可能应用</span>
</blockquote>

               -->
            </article>
          </div>
        </div>
      </main>
      
        
<script>function scrollFunction(){20<document.body.scrollTop||20<document.documentElement.scrollTop?document.getElementById("myBtn").style.display="block":document.getElementById("myBtn").style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}window.onscroll=function(){scrollFunction()}</script>
<button onclick="topFunction()" id="myBtn" class="data-tip-left" data-tip="回到顶部">
  <svg class="Zi Zi--BackToTop data-tip-left" data-tip="回到顶部" fill="currentColor" viewBox="0 0 24 24" width="24" height="24">
    <path d="M16.036 19.59a1 1 0 0 1-.997.995H9.032a.996.996 0 0 1-.997-.996v-7.005H5.03c-1.1 0-1.36-.633-.578-1.416L11.33 4.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.005z"></path>
  </svg>
</button>
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../ConcurrentHashMap%281.8%E7%89%88%E6%9C%AC%29%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="ConcurrentHashMap" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                ConcurrentHashMap
              </span>
            </div>
          </a>
        
        
          <a href="../Redis-CheatSheet/" title="Redis" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                Redis
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
        <div id="miitbeian"></div>
      </div>
      
      <span style="float:right" class="build_date_utc"><a href="https://github.com/24OI/OI-wiki">最近更新：, 2021-09-29</a></span>
      <script>
        /* miitbeian */
        if (window.location.hostname == "oi-wiki.com") {
          document.getElementById("miitbeian").innerHTML = `<a href="http://beian.miit.gov.cn/">黑ICP备19005132号-2</a>`;
        }
        /* Easter Egg */
        console.log(`%c OI Wiki %c  %c`,"background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff","background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff","background:transparent");
        console.log('少年，恭喜你囍提彩蛋，我们在做一些 OI 相关的有趣的事情，如果您对此感兴趣，欢迎访问 https://join-us.oi-wiki.org');
      </script>
      
    </div>
    <div class="sponsor" style="text-align:center;color:#fff;vertical-align:middle">
      Supported by <span>
      <a href="/intro/hulu/">
        <img src="https://cdn.jsdelivr.net/npm/oicdn@0.0.1/hulu-white.png" style="vertical-align:-12px;width:125px;margin-left:5px">
      </a>
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.ad30b88d.js"></script>
      <script>app.initialize({version:"1.2.2",url:{base:"../.."}}),"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js",{scope:"/"}).then(function(e){console.log("PWA Registration succeeded. Scope is "+e.scope)}).catch(function(e){console.log("PWA Registration failed with "+e)})</script>
      
    
  </body>
</html>