



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta http-equiv="x-dns-prefetch-control" content="on">
      <link rel="dns-prefetch" href="//oi-wiki.org">
      <link rel="dns-prefetch" href="//search.oi-wiki.org">
      <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
      <link rel="dns-prefetch" href="//api.github.com">
      <link rel="dns-prefetch" href="//cdn-for-oi-wiki.billchn.com">
      <link rel="dns-prefetch" href="//www.google-analytics.com">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="https://xiaocairush.github.io/java%E5%90%8E%E7%AB%AF/ConcurrentHashMap%281.8%E7%89%88%E6%9C%AC%29%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../..">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-4.4.2">
    
    
      
        <title>ConcurrentHashMap(1.8版本)源码剖析</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.30686662.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../assets/javascripts/modernizr.27508f0e.js"></script>
    
    
      
        <style>@font-face{font-family:'Fira Sans';font-style:normal;font-weight:300;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:italic;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot);src:local('Fira Sans'),local('FiraSans-Italic'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:700;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Mono';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot);src:local('Fira Mono'),local('FiraMono-Normal'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.svg#FiraMono) format('svg')}body,input{font-family:"Fira Sans","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Fira Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.2.3/iconfont/material-icons.min.css">
    
      <link rel="manifest" href="../../manifest.webmanifest">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#concurrenthashmap18" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://xiaocairush.github.io/" title="知识总结" class="md-header-nav__button md-logo">
          
            <i class="md-icon">school</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              知识总结
            </span>
            <span class="md-header-nav__topic">
              
                ConcurrentHashMap(1.8版本)源码剖析
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../ZooKeeper-overview/" class="md-tabs__link md-tabs__link--active">
          java后端
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://xiaocairush.github.io/" title="知识总结" class="md-nav__button md-logo">
      
        <i class="md-icon">school</i>
      
    </a>
    知识总结
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../about.md" title="About" class="md-nav__link">
      About
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      java后端
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        java后端
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../ZooKeeper-overview/" title="ZooKeeper" class="md-nav__link">
      ZooKeeper
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spark-Overview/" title="Spark" class="md-nav__link">
      Spark
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Resources/" title="Resources" class="md-nav__link">
      Resources
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="同步工具类" class="md-nav__link">
      同步工具类
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../java-SE8-in-practice/" title="java-SE8-in-practice" class="md-nav__link">
      java-SE8-in-practice
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../vim-learning-notes/" title="vim" class="md-nav__link">
      vim
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../understanding-REST/" title="理解REST" class="md-nav__link">
      理解REST
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../spring-callstack/" title="spring" class="md-nav__link">
      spring
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../BlockingQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="BlockingQueue源码剖析" class="md-nav__link">
      BlockingQueue源码剖析
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        ConcurrentHashMap
      </label>
    
    <a href="./" title="ConcurrentHashMap" class="md-nav__link md-nav__link--active">
      ConcurrentHashMap
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forwardingnode" class="md-nav__link">
    ForwardingNode
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treenode" class="md-nav__link">
    TreeNode
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treebin" class="md-nav__link">
    TreeBin
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    核心成员
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    核心函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concurrenthashmapint-initialcapacity" class="md-nav__link">
    ConcurrentHashMap(int initialCapacity)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inittable" class="md-nav__link">
    initTable
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#put" class="md-nav__link">
    put
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get" class="md-nav__link">
    get
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treeifybin" class="md-nav__link">
    treeifyBin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trypresize" class="md-nav__link">
    tryPresize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer" class="md-nav__link">
    transfer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#addcount" class="md-nav__link">
    addCount
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      <!-- 
      
       -->
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../java.util.concurrent.locks%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="java.util.concurrent.locks源码剖析" class="md-nav__link">
      java.util.concurrent.locks源码剖析
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Redis-CheatSheet/" title="Redis" class="md-nav__link">
      Redis
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forwardingnode" class="md-nav__link">
    ForwardingNode
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treenode" class="md-nav__link">
    TreeNode
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treebin" class="md-nav__link">
    TreeBin
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    核心成员
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    核心函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concurrenthashmapint-initialcapacity" class="md-nav__link">
    ConcurrentHashMap(int initialCapacity)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inittable" class="md-nav__link">
    initTable
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#put" class="md-nav__link">
    put
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get" class="md-nav__link">
    get
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treeifybin" class="md-nav__link">
    treeifyBin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trypresize" class="md-nav__link">
    tryPresize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer" class="md-nav__link">
    transfer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#addcount" class="md-nav__link">
    addCount
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      <!-- 
      
       -->
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="concurrenthashmap18">ConcurrentHashMap(1.8版本)源码剖析<a class="headerlink" href="#concurrenthashmap18" title="Permanent link">&para;</a></h1>
<p>基于jdk1.8。</p>
<p>参考文章：
<a href="https://yq.aliyun.com/articles/36781">https://yq.aliyun.com/articles/36781</a> <br/>
<a href="http://blog.csdn.net/u012834750/article/details/71536618">http://blog.csdn.net/u012834750/article/details/71536618</a></p>
<h2 id="_1">数据结构<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>仅列出最重要的代码片段</p>
<h3 id="node">Node<a class="headerlink" href="#node" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        volatile V val;
        volatile Node&lt;K,V&gt; next;

        /**
         * 子类中重写了这个方法，这里的find实现了在链表中查找hash值等于h且key等于k的节点
         */
        Node&lt;K,V&gt; find(int h, Object k) {
            Node&lt;K,V&gt; e = this;
            if (k != null) {
                do {
                    K ek;
                    if (e.hash == h &amp;&amp;
                        ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))
                        return e;
                } while ((e = e.next) != null);
            }
            return null;
        }
 }
</pre></div>
</td></tr></table>
<h3 id="forwardingnode">ForwardingNode<a class="headerlink" href="#forwardingnode" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     /**
     * A node inserted at head of bins during transfer operations.
     */
     // 并不是我们传统的包含key-value的节点，只是一个标志节点，并且指向nextTable，提供find方法而已。生命周期：仅存活于扩容操作且bin不为null时，一定会出现在每个bin的首位。
    static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {
        final Node&lt;K,V&gt;[] nextTable;
        ForwardingNode(Node&lt;K,V&gt;[] tab) {
            super(MOVED, null, null, null);
            this.nextTable = tab;
        }

        Node&lt;K,V&gt; find(int h, Object k) {
            // loop to avoid arbitrarily deep recursion on forwarding nodes
            outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {
                Node&lt;K,V&gt; e; int n;
                if (k == null || tab == null || (n = tab.length) == 0 ||
                    (e = tabAt(tab, (n - 1) &amp; h)) == null)// 头结点存在e中
                    return null;
                for (;;) {
                // 检查头结点是否为要找的node
                    int eh; K ek;
                    if ((eh = e.hash) == h &amp;&amp;
                        ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))
                        return e;
                        // 如果头结点不是要找的节点
                    if (eh &lt; 0) {
                        // 头结点hash值小于0
                        // 如果头结点是ForwardingNode，那么继续下一个ForwardingNode的find逻辑
                        if (e instanceof ForwardingNode) {
                            tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;
                            continue outer;
                        }
                        // 如果头结点不是ForwardingNode，就进行相应的find逻辑
                        else
                            return e.find(h, k);
                    }
                    // 查找到尾部仍然没有找到对应的node
                    if ((e = e.next) == null)
                        return null;
                }
            }
        }
    }
</pre></div>
</td></tr></table>
<h3 id="treenode">TreeNode<a class="headerlink" href="#treenode" title="Permanent link">&para;</a></h3>
<p>红黑树中的节点类，值得注意的是：TreeNode可用于构造双向链表，Node包含next成员，同时，TreeNode加入了prev成员。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span></span>static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; {
        TreeNode&lt;K,V&gt; parent;  // red-black tree links
        TreeNode&lt;K,V&gt; left;
        TreeNode&lt;K,V&gt; right;
        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
        boolean red;

        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next,
                 TreeNode&lt;K,V&gt; parent) {
            super(hash, key, val, next);
            this.parent = parent;
        }

        Node&lt;K,V&gt; find(int h, Object k) {
            return findTreeNode(h, k, null);
        }

        final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) {
            if (k != null) {
                TreeNode&lt;K,V&gt; p = this;
                do  {
                    int ph, dir; K pk; TreeNode&lt;K,V&gt; q;
                    TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;
                    if ((ph = p.hash) &gt; h)
                        p = pl;
                    else if (ph &lt; h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))
                        return p;
                    // hash值相等，key不等，左子树不存在，搜索右子树
                    else if (pl == null)
                        p = pr;
                    // hash值相等，key不等，右子树不存在，搜索左子树
                    else if (pr == null)
                        p = pl;
                   /*
                    * comparableClassFor的作用是:
                    * 如果k实现了Comparable接口，返回k的Class,
                    * 否则返回null。
                    * compareComparables的作用是：
                    * 将k与pk做比较
                    * 如果TreeNode的Key可以作比较，就可以继续在树中搜索
                    */
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &amp;&amp;
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir &lt; 0) ? pl : pr;
                    // 由于hash相等，key无法做比较，因此先在右子树中找
                    else if ((q = pr.findTreeNode(h, k, kc)) != null)
                        return q;
                    // 右子树没有找到，继续从当前的节点的左子树中找
                    else
                        p = pl;
                } while (p != null);
            }
            return null;
        }
    }
</pre></div>
</td></tr></table>
<h3 id="treebin">TreeBin<a class="headerlink" href="#treebin" title="Permanent link">&para;</a></h3>
<p>TreeBin封装了红黑树的逻辑，有关红黑树, 可以参考的资料有<a href="http://algs4.cs.princeton.edu/33balanced/">《Algorithm》网站</a> 以及 <a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html">中文翻译</a></p>
<p>也可以试玩<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">Red/Black Tree Visualization</a> 。</p>
<p>附文章中提到的红黑树旋转的动图与TreeBin中的rotateLeft、rotateRight代码片段帮助理解。</p>
<p>左旋：
<img alt="rotateLeft" src="http://img.blog.csdn.net/20170920113731723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3V5Y2FuZHk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></p>
<p>对应代码
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,
                                              TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; r, pp, rl;
            // p是图中的E节点，r是图中的S节点
            if (p != null &amp;&amp; (r = p.right) != null) {
                if ((rl = p.right = r.left) != null)
                    rl.parent = p;
                // p是根节点，则根节点需要变化
                if ((pp = r.parent = p.parent) == null)
                    (root = r).red = false;
                // p不是根节点，如果p是pp的左节点，就更新pp的left
                else if (pp.left == p)
                    pp.left = r;
                else
                    pp.right = r;
                // 把p放在左子树中
                r.left = p;
                p.parent = r;
            }
            return root;
        }
</pre></div>
</td></tr></table></p>
<p>右旋：
<img alt="rotateRight" src="http://img.blog.csdn.net/20170920113827242?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3V5Y2FuZHk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></p>
<p>对应代码</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,
                                               TreeNode&lt;K,V&gt; p) {
            TreeNode&lt;K,V&gt; l, pp, lr;
            // p是途中的S，l是图中的E
            if (p != null &amp;&amp; (l = p.left) != null) {
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
                // p是根节点，则根节点需要变化
                if ((pp = l.parent = p.parent) == null)
                    (root = l).red = false;
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
            return root;
        }
</pre></div>
</td></tr></table>
<p>仅列出Treebin数据成员以及部分方法：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232</pre></div></td><td class="code"><div class="highlight"><pre><span></span>// 维护了一个红黑树
static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; {
        TreeNode&lt;K,V&gt; root;
        // 链表头结点，每次都将新节点插入到链表的头部，成为新的头结点
        // 因此该链表中节点的顺序与插入顺序相反
        volatile TreeNode&lt;K,V&gt; first;
        volatile Thread waiter;
        volatile int lockState;

         /**
         * 返回匹配的node或者没有匹配的就返回null. 在树中从根节点开始比较，
         * 当锁不可用的时候进行线性搜索
         */
        final Node&lt;K,V&gt; find(int h, Object k) {
            if (k != null) {
                for (Node&lt;K,V&gt; e = first; e != null; ) {
                    int s; K ek;
                    // 锁不可用，lockState包含了WAITER或者WRITER标志位
                    if (((s = lockState) &amp; (WAITER|WRITER)) != 0) {
                        if (e.hash == h &amp;&amp;
                            ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))
                            return e;
                        e = e.next;
                    }
                    // 锁可用，当前对象设置为READER状态
                    else if (U.compareAndSwapInt(this, LOCKSTATE, s,
                                                 s + READER)) {
                        TreeNode&lt;K,V&gt; r, p;
                        try {
                            // 在树中查找匹配的节点
                            p = ((r = root) == null ? null :
                                 r.findTreeNode(h, k, null));
                        } finally {
                            Thread w;
                            // 取消当前锁的READER状态
                            if (U.getAndAddInt(this, LOCKSTATE, -READER) ==
                                (READER|WAITER) &amp;&amp; (w = waiter) != null)
                                LockSupport.unpark(w);
                        }
                        return p;
                    }
                }
            }
            return null;
        }

         // 寻找或者添加一个节点
        final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) {
            Class&lt;?&gt; kc = null;
            boolean searched = false;
            for (TreeNode&lt;K,V&gt; p = root;;) {
                int dir, ph; K pk;
                //  红黑树是空，直接插入到根节点
                if (p == null) {
                    first = root = new TreeNode&lt;K,V&gt;(h, k, v, null, null);
                    break;
                }
                // 根据hash值设置标记位
                else if ((ph = p.hash) &gt; h)
                    dir = -1;
                else if (ph &lt; h)
                    dir = 1;
                // hash值相同，并且k与pk相等（equals），直接返回
                else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))
                    return p;
                // hash相同，p与pk不equals，但是按照比较接口发现p与pk相等
                else if ((kc == null &amp;&amp;
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (!searched) {
                        TreeNode&lt;K,V&gt; q, ch;
                        searched = true;
                        if (((ch = p.left) != null &amp;&amp;
                             (q = ch.findTreeNode(h, k, kc)) != null) ||
                            ((ch = p.right) != null &amp;&amp;
                             (q = ch.findTreeNode(h, k, kc)) != null))
                            return q;
                    }
                    // 根据一种确定的规则来进行比较，至于规则本身具体是什么病不重要
                    dir = tieBreakOrder(k, pk);
                }

                // 程序运行到这里，说明当前节点不匹配，但子树中可能会有匹配的Node
                TreeNode&lt;K,V&gt; xp = p;
                // 根据大小关系移动p到左子树或者右子树
                // 如果满足p为null，则说明树中没有节点能与之匹配，应当在p位置插入新节点，然后维护红黑树的性质
                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                    TreeNode&lt;K,V&gt; x, f = first;
                    first = x = new TreeNode&lt;K,V&gt;(h, k, v, f, xp);
                    if (f != null)
                        f.prev = x;
                    if (dir &lt;= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    // 优先将新节点染为红色
                    if (!xp.red)
                        x.red = true;
                    else {
                        lockRoot();
                        try {
                            root = balanceInsertion(root, x);
                        } finally {
                            unlockRoot();
                        }
                    }
                    break;
                }
            }
            assert checkInvariants(root);
            return null;
        }
}

// 红黑树的平衡插入
static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,
                                                    TreeNode&lt;K,V&gt; x) {
            x.red = true; // 将x染成红色
            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {
                // 根节点必须是黑色
                if ((xp = x.parent) == null) {
                    x.red = false;
                    return x;
                }
                // 父节点是黑色或者父节点是根节点
                // 总之父节点是黑色，那么不会违反红黑树性质
                // 不需要调整结构，直接返回根节点即可
                else if (!xp.red || (xpp = xp.parent) == null)
                    return root;
                // 父节点是红色（需要调整），且在祖父节点的左子树中
                if (xp == (xppl = xpp.left)) {
                    // 因为父节点为红色，所以xppr必须是红色或空，不可能是黑色
                    // 祖父节点的右节点为红色
                    if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {

                   /**
                     *     黑                  红
                     *    /  \    （染色后）    / \
                     *   红   红    -&gt;        黑  黑
                     *  /                   /
                     * 红                  红
                     * 
                     * 可见通过调整颜色后，子树不需要旋转就可以满足红黑树的性质
                     * 但由于xpp变成了红色，有可能违反红黑树性质，仍然需要向上调整
                    */

                        xppr.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    // xppr是空
                    else {
                       /**
                        *      黑
                        *     /
                        *    红 
                        *      \
                        *       红
                        */
                        if (x == xp.right) {
                            /**
                                * 进行左旋操作，变为以下形式，
                                * 可以看出此时任然违反红黑树的性质，
                                * 然而x仍然指向了最下面冲突的红色节点，
                                * 此处仅仅调整了树的形状
                                *
                                *      黑
                                *     /
                                *    红
                                *   /
                                *  红
                                */
                            root = rotateLeft(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        /*
                         * 由于调整了树的形状，因此此时树一定长成这个样子
                         * 
                         *      黑
                         *     /
                         *    红
                         *   /
                         *  红
                         * 
                         * 在染色并右旋之后，变为
                         * 
                         *    黑
                         *   /  \
                         * 红     红
                         */
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;

                                root = rotateRight(root, xpp);
                            }
                        }
                    }
                }
                // x在祖父节点的右子树中，这种情况与x在祖父节点左子树中类似，因此不多作解释，不明白的话类比即可。
                else {
                /**
                *   黑                    红
                *  /  \     (染色后)      / \
                * 红    红   -&gt;         黑   黑
                *        \                    \
                *         红                   红色
                */
                    if (xppl != null &amp;&amp; xppl.red) {
                        xppl.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.left) {
                            root = rotateRight(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }
</pre></div>
</td></tr></table>
<h2 id="_2">核心成员<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    // ForwardingNode的hash值都是-1
    static final int MOVED     = -1; 
    // Treebin的hash值是-1
    static final int TREEBIN   = -2; 

    /**
     * 在第一次insert的时候才进行初始化(延迟初始化)
     * Size总是2的幂. 直接通过迭代器访问.
     */
    transient volatile Node&lt;K,V&gt;[] table;

    // nextTable的用途：只有在扩容时是非空的
    private transient volatile Node&lt;K,V&gt;[] nextTable;

    /**
     * Base counter value, used mainly when there is no contention,
     * but also as a fallback during table initialization
     * races. Updated via CAS.
     */
    private transient volatile long baseCount;

    /**
     * sizeCtl是控制标识符，不同的值表示不同的意义。
     * -1代表正在初始化； 
     * -(1+有效扩容线程的数量)，比如，-N 表示有N-1个线程正在进行扩容操作；
     * 0 表示还未进行初始化
     * 正数代表初始化或下一次进行扩容的大小，类似于扩容阈值。它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。实际容量&gt;=sizeCtl，则扩容。
     */
    private transient volatile int sizeCtl;


     // 扩容的时候，next数组下标+1
    private transient volatile int transferIndex;

    /**
     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.
     */
    private transient volatile int cellsBusy;

    /**
     * Table of counter cells. When non-null, size is a power of 2.
     */
    private transient volatile CounterCell[] counterCells;

    // 视图
    private transient KeySetView&lt;K,V&gt; keySet;
    private transient ValuesView&lt;K,V&gt; values;
    private transient EntrySetView&lt;K,V&gt; entrySet;
</pre></div>
</td></tr></table>
<h2 id="_3">核心函数<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<h3 id="concurrenthashmapint-initialcapacity">ConcurrentHashMap(int initialCapacity)<a class="headerlink" href="#concurrenthashmapint-initialcapacity" title="Permanent link">&para;</a></h3>
<p>之所以列出这个函数，是因为这个函数初始化了sizeCtl，并且可以看出table在这里并没有被初始化，而是在插入元素的时候进行延迟初始化。
我们要注意的是table的长度始终是2的幂，sizeCtl的值为正数时表示扩容的最小阀值。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span> // 需要注意的是，构造了一个能够容纳initialCapacity个元素的对象，
 // 但实际table的大小比1.5倍的initialCapacity还多
 public ConcurrentHashMap(int initialCapacity) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException();
        // 保证cap是2的幂，其中tableSizeFor返回大于入参的最小的2的幂
        int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));
        this.sizeCtl = cap;
    }
</pre></div>
</td></tr></table>
<h3 id="inittable">initTable<a class="headerlink" href="#inittable" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     // 初始化table，使用sizeCtl记录table的容量
     // 为了保证并发访问不会出现冲突，使用了Unsafe的CAS操作
    private final Node&lt;K,V&gt;[] initTable() {
        Node&lt;K,V&gt;[] tab; int sc;
        // tab是空的
        while ((tab = table) == null || tab.length == 0) {
            // 如果已经初始化过
            if ((sc = sizeCtl) &lt; 0)
                Thread.yield(); // 退出初始化数组的竞争; just spin
            // 如果没有线程在初始化，将sizeCtl设置为-1，表示正在初始化
            // CAS操作，由此可见sizeCtl维护table的并发访问
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    // 再次检查table是否为空
                    if ((tab = table) == null || tab.length == 0) {
                        // 计算分配多少个Node
                        // sc大于0的时候表示要分配的大小
                        // 否则默认分配16个node
                        int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings(&quot;unchecked&quot;)
                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                        table = tab = nt;
                        // 下次扩容的最小阀值0.75*n
                        // 注意0.75 * n &lt; n，而且它很可能不是2的幂，
                        // 例如n = 16， 则sc = 12；
                        // 因此这个阀值在后续扩容情况下实际上不会成为数组的容量值，但它可以用来能保证用户提供了容量大小时，能够容纳用户要求数目的元素。
                        sc = n - (n &gt;&gt;&gt; 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
</pre></div>
</td></tr></table>
<h3 id="put">put<a class="headerlink" href="#put" title="Permanent link">&para;</a></h3>
<p>put过程的描述：</p>
<p>为表述方便，用符号i 来表示 (n - 1) &amp; hash，用newNode表示使用key,value创建的节点</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span>loop:
{
    if table == null
    {
        初始化一个默认长度为16的数组
    }
    else table[i] == null
    {   
        table[i] = newNode
    }
    else hash == -1，table[i]是ForwardingNode
    {
        进行整合表的操作
    }
    else
    {
        if hash &gt;= 0，table[i]不是特殊Node(链表中的Node)
        {
            将newNode插入到链表中
        }
        else table[i]是TreeBin
        {
             newNode插入到TreeNode中
        }
    }
    addCount(1L, binCount);
}
</pre></div>
</td></tr></table>
<p>通过研读代码，发现Doug Lea使用了一种有效且高效的技巧：
在循环里面嵌套使用CAS操作。这种技巧把临界区变得很小，因此比较高效。</p>
<p>put源码如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    public V put(K key, V value) {
        return putVal(key, value, false);
    }

/** put和putIfAbsent都是通过调用putVal方法来实现的*/
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        // ConcurrentHashMap不支持key和value是null
        if (key == null || value == null) throw new NullPointerException();
        // 获取hash值
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            // case 1：tab为null，需要初始化tab
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            // case 2: 没有任何节点hash值与当前要插入的节点相同
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            // case 3: 当遇到表连接点时，需要进行整合表的操作
            // 需要注意的是，遇到连接点的时候，并没有插入新节点，仅仅帮助扩容，因为当前线程迫切需要尽快插入新节点，只能等待扩容完毕才有可能插入新节点
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            // case 4: 找到对应于hash值的链表首节点，且该节点不是连接节点
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                // 如果找到相同key的node，根据onlyIfAbsent来更新node的值
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                // 如果一直到链表的尾部都没有找到任何node的key与key相同，就插入到链表的尾部
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        // 如果该节点是TreeBin，就插入到TreeBin中
                        else if (f instanceof TreeBin) {
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            // 当存在相同的key时，putTreeVal不会修改那个TreeNode，而是返回给p，由onlyIfAbsent决定是否修改p.val
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                // 若链表长度不低于8，就将链表转换为树
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        // 添加计数，如有需要，扩容
        addCount(1L, binCount);
        return null;
    }

    // 给tab[i]赋值
    // 如果tab[i]等于c,就将tab[i]与v交换数值
    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,
                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {
        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);
    }

    /**
    * 协助扩容方法。
    * 多线程下，当前线程检测到其他线程正进行扩容操作，则协助其一起扩容；
    *（只有这种情况会被调用）从某种程度上说，其“优先级”很高，
    * 只要检测到扩容，就会放下其他工作，先扩容。
    * 调用之前，nextTable一定已存在。
    */
    final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {
        Node&lt;K,V&gt;[] nextTab; int sc;
        // 如果f是tab中的连接节点，并且它所连接的table非空
        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;
            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {
            // 标志位
            int rs = resizeStamp(tab.length);
            // 当正在扩容时，帮助扩容
            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;
                   (sc = sizeCtl) &lt; 0) {
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                    transfer(tab, nextTab);
                    break;
                }
            }
            return nextTab;
        }
        return table;
    }
</pre></div>
</td></tr></table>
<h3 id="get">get<a class="headerlink" href="#get" title="Permanent link">&para;</a></h3>
<p>get方法比较简单，没有使用锁，而是用Unsafe来保证获取的头结点是volatile的</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span> public V get(Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
        // 获取hash值h
        int h = spread(key.hashCode());
        // tab只是保存了hash值相同的头结点
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; // table里面有元素
            (e = tabAt(tab, (n - 1) &amp; h)) != null) {// 根据h来获取头结点e
            // hash值相同，如果找到key，直接返回
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                    return e.val;
            }
            // todo：看一下hash值什么时候小于0
            else if (eh &lt; 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            while ((e = e.next) != null) {
                if (e.hash == h &amp;&amp;
                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }

//tableAt方法使用了Unsafe对象来获取数组中下标为i的对象
static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
        // 第i个元素实际地址i * (2^ASHIFT) + ABASE
        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
    }
</pre></div>
</td></tr></table>
<h3 id="treeifybin">treeifyBin<a class="headerlink" href="#treeifybin" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     // 如果tab的长度很小，小于64个，就尝试进行扩容为两倍，
     // 否则就将以tab[index]开头的链表转换为Treebin
    private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {
        Node&lt;K,V&gt; b; int n, sc;
        if (tab != null) {
            // tab的长度小于64，就尝试进行扩容
            if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
                tryPresize(n &lt;&lt; 1);
            else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {
                synchronized (b) {
                    if (tabAt(tab, index) == b) {
                        TreeNode&lt;K,V&gt; hd = null, tl = null;
                        // 这个循环建立了TreeNode中的双向链表，hd保存了双向链表的头结点
                        for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {
                            TreeNode&lt;K,V&gt; p =
                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,
                                                  null, null);
                            if ((p.prev = tl) == null)
                                hd = p;
                            else
                                tl.next = p;
                            tl = p;
                        }
                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));
                    }
                }
            }
        }
    }
</pre></div>
</td></tr></table>
<h3 id="trypresize">tryPresize<a class="headerlink" href="#trypresize" title="Permanent link">&para;</a></h3>
<p>有关扩容，可以参考<a href="http://www.jianshu.com/p/f6730d5784ad">深入分析 ConcurrentHashMap 1.8 的扩容实现</a> 这篇文章。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    // 尝试扩容使它能放size个元素
    private final void tryPresize(int size) {
        // 计算扩容后的数量
        int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :
            tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);
        int sc;
        while ((sc = sizeCtl) &gt;= 0) {
            Node&lt;K,V&gt;[] tab = table; int n;
            // 如果tab是空的，直接扩容
            if (tab == null || (n = tab.length) == 0) {
                // 计算扩容后的容量
                n = (sc &gt; c) ? sc : c;
                if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                    try {
                        if (table == tab) {
                            @SuppressWarnings(&quot;unchecked&quot;)
                            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                            table = nt;
                            // 下次扩容的容量阀值是0.75 * n
                            sc = n - (n &gt;&gt;&gt; 2);
                        }
                    } finally {
                        sizeCtl = sc;
                    }
                }
            }
            // 容量已经够用，不需要进行扩容；或者容量太大，无法进行扩容。
            else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)
                break;
            // 仍然需要扩容
            else if (tab == table) {
                int rs = resizeStamp(n);
                // todo：不是很懂为什么会出现 sc &lt; 0 ？先看一下transfer的实现
                if (sc &lt; 0) {
                    Node&lt;K,V&gt;[] nt;
                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex &lt;= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
            }
        }
    }
</pre></div>
</td></tr></table>
<h3 id="transfer">transfer<a class="headerlink" href="#transfer" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span>伪代码：

n = table.length

nextTable = new Node[2 * n]

forwardingNode = new ForwardingNode

forwardingNode.nextTable = nextTable;

for(table[i] : table)
{
    for(p = table[i]; p != null ; p = p.next)
    {
        if(p.hash &amp; n == 0)
            将p放入nextTable[i]的数据集合中
        else
            将p放入nextTable[i+n]的数据集合中
    }
    table[i] = forwardingNode;
}

table = nextTable;

nextTable = null;
</pre></div>
</td></tr></table>
<p>数学公式：</p>
<blockquote>
<p>已知：n = 2 ^ k ， hash &amp; (n-1) = i，显而易见：
（1）若 hash &amp; n = 0， 则 hash &amp;(2<em>n - 1) = i ；
（2）若 hash &amp; n != 0,  则 hash&amp;(2</em>n - 1) = i + n。</p>
</blockquote>
<p>源代码在此：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     // 把table中所有的Node放入新的table中
    private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {
        int n = tab.length, stride;
        if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
            stride = MIN_TRANSFER_STRIDE; // subdivide range
        if (nextTab == null) {            // initiating
            try {
                @SuppressWarnings(&quot;unchecked&quot;)
                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
                nextTab = nt;
            } catch (Throwable ex) {      // try to cope with OOME
                sizeCtl = Integer.MAX_VALUE;
                return;
            }
            nextTable = nextTab;
            transferIndex = n;
        }
        int nextn = nextTab.length;
        ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
        boolean advance = true;
        boolean finishing = false; // to ensure sweep before committing nextTab
        for (int i = 0, bound = 0;;) {
            Node&lt;K,V&gt; f; int fh;
            while (advance) {
                int nextIndex, nextBound;
                if (--i &gt;= bound || finishing)
                    advance = false;
                else if ((nextIndex = transferIndex) &lt;= 0) {
                    i = -1;
                    advance = false;
                }
                else if (U.compareAndSwapInt
                         (this, TRANSFERINDEX, nextIndex,
                          nextBound = (nextIndex &gt; stride ?
                                       nextIndex - stride : 0))) {
                    bound = nextBound;
                    i = nextIndex - 1;
                    advance = false;
                }
            }
            if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
                int sc;
                if (finishing) {
                    nextTable = null;
                    table = nextTab;
                    sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
                    return;
                }
                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                        return;
                    finishing = advance = true;
                    i = n; // recheck before commit
                }
            }
            else if ((f = tabAt(tab, i)) == null)
                advance = casTabAt(tab, i, null, fwd);
            else if ((fh = f.hash) == MOVED)
                advance = true; // already processed
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        Node&lt;K,V&gt; ln, hn;
                        if (fh &gt;= 0) {

                            int runBit = fh &amp; n;
                            Node&lt;K,V&gt; lastRun = f;
                            for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {
                                int b = p.hash &amp; n;
                                if (b != runBit) {
                                    runBit = b;
                                    lastRun = p;
                                }
                            }
                            if (runBit == 0) {
                                ln = lastRun;
                                hn = null;
                            }
                            else {
                                hn = lastRun;
                                ln = null;
                            }
                            for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {
                                int ph = p.hash; K pk = p.key; V pv = p.val;
                                if ((ph &amp; n) == 0)
                                    ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
                                else
                                    hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
                            }
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                        else if (f instanceof TreeBin) {
                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
                            TreeNode&lt;K,V&gt; lo = null, loTail = null;
                            TreeNode&lt;K,V&gt; hi = null, hiTail = null;
                            int lc = 0, hc = 0;
                            for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {
                                int h = e.hash;
                                TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;
                                    (h, e.key, e.val, null, null);
                                if ((h &amp; n) == 0) {
                                    if ((p.prev = loTail) == null)
                                        lo = p;
                                    else
                                        loTail.next = p;
                                    loTail = p;
                                    ++lc;
                                }
                                else {
                                    if ((p.prev = hiTail) == null)
                                        hi = p;
                                    else
                                        hiTail.next = p;
                                    hiTail = p;
                                    ++hc;
                                }
                            }
                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                                (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                                (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                    }
                }
            }
        }
    }
</pre></div>
</td></tr></table>
<h3 id="addcount">addCount<a class="headerlink" href="#addcount" title="Permanent link">&para;</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    /**
     * Adds to count, and if table is too small and not already
     * resizing, initiates transfer. If already resizing, helps
     * perform transfer if work is available.  Rechecks occupancy
     * after a transfer to see if another resize is already needed
     * because resizings are lagging additions.
     *
     * @param x the count to add
     * @param check if &lt;0, don&#39;t check resize, if &lt;= 1 only check if uncontended
     */
    // 添加计数，如果table太小且table没有在扩容，就进行扩容
    private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        // 利用CAS快速更新baseCount的值
        if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) &lt; 0 ||
                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                fullAddCount(x, uncontended);
                return;
            }
            if (check &lt;= 1)
                return;
            s = sumCount();
        }

        // 当之前检查的节点个数大于等于0时，才考虑扩容
        if (check &gt;= 0) {
            Node&lt;K,V&gt;[] tab, nt; int n, sc;
            while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
                   (n = tab.length) &lt; MAXIMUM_CAPACITY) {
                // 为当前的n保留一个数，不同的数组n（这里n=2^k）得到的结果必然不同，可类比时间戳
                int rs = resizeStamp(n);
                // 如果有线程正在扩容，就帮助其扩容
                if (sc &lt; 0) {
                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex &lt;= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                // 没有线程在扩容，直接扩容
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
                s = sumCount();
            }
        }
    }
</pre></div>
</td></tr></table>
                
                  
                
              
              <!-- 
                 
 
 
<hr><blockquote class="page-copyright">
  <span><i class="md-icon">build</i>本页面最近更新：</span><span class="facts_modified"></span>，<a class="edit_history">更新历史</a><br>
  <span><i class="md-icon">edit</i>发现错误？想一起完善？ <a href="None" title="编辑此页" class="page_edit_url">在 GitHub 上编辑此页！</a></span><br>
  <span><i class="md-icon">people</i>本页面贡献者：</span><span class="page_contributors">OI-wiki</span><br>
  <span><i class="md-icon">copyright</i>本页面的全部内容在 <strong></strong> 协议之条款下提供，附加条款亦可能应用</span>
</blockquote>

               -->
            </article>
          </div>
        </div>
      </main>
      
        
<script>function scrollFunction(){20<document.body.scrollTop||20<document.documentElement.scrollTop?document.getElementById("myBtn").style.display="block":document.getElementById("myBtn").style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}window.onscroll=function(){scrollFunction()}</script>
<button onclick="topFunction()" id="myBtn" class="data-tip-left" data-tip="回到顶部">
  <svg class="Zi Zi--BackToTop data-tip-left" data-tip="回到顶部" fill="currentColor" viewBox="0 0 24 24" width="24" height="24">
    <path d="M16.036 19.59a1 1 0 0 1-.997.995H9.032a.996.996 0 0 1-.997-.996v-7.005H5.03c-1.1 0-1.36-.633-.578-1.416L11.33 4.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.005z"></path>
  </svg>
</button>
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../BlockingQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="BlockingQueue源码剖析" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                BlockingQueue源码剖析
              </span>
            </div>
          </a>
        
        
          <a href="../java.util.concurrent.locks%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="java.util.concurrent.locks源码剖析" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                java.util.concurrent.locks源码剖析
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
        <div id="miitbeian"></div>
      </div>
      
      <span style="float:right" class="build_date_utc"><a href="https://github.com/24OI/OI-wiki">最近更新：, 2021-09-29</a></span>
      <script>
        /* miitbeian */
        if (window.location.hostname == "oi-wiki.com") {
          document.getElementById("miitbeian").innerHTML = `<a href="http://beian.miit.gov.cn/">黑ICP备19005132号-2</a>`;
        }
        /* Easter Egg */
        console.log(`%c OI Wiki %c  %c`,"background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff","background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff","background:transparent");
        console.log('少年，恭喜你囍提彩蛋，我们在做一些 OI 相关的有趣的事情，如果您对此感兴趣，欢迎访问 https://join-us.oi-wiki.org');
      </script>
      
    </div>
    <div class="sponsor" style="text-align:center;color:#fff;vertical-align:middle">
      Supported by <span>
      <a href="/intro/hulu/">
        <img src="https://cdn.jsdelivr.net/npm/oicdn@0.0.1/hulu-white.png" style="vertical-align:-12px;width:125px;margin-left:5px">
      </a>
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.ad30b88d.js"></script>
      <script>app.initialize({version:"1.2.2",url:{base:"../.."}}),"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js",{scope:"/"}).then(function(e){console.log("PWA Registration succeeded. Scope is "+e.scope)}).catch(function(e){console.log("PWA Registration failed with "+e)})</script>
      
    
  </body>
</html>